
* Introduction


the whole purpose of this system is to have distributed video and audio encoding, decoding and filtering.

The system operates by having master node and shared storage for data and other worker nodes to do processing with master node.
  
* Use cases

the usage of the system would be as follows:

#+begin_src bash
  disttranscode --input location --filter f1 param1 param2 --filter f2 param1 param2 output-location
#+end_src

and available filters which can be applied would be:

+ id - copy video
+ grayscale - convert video to grayscale
+ resize newwidth newheight - resize video
+ watermark x y text fontsize color startFrame endFrame - put watermark on video
+ image x y image-location startFrame endFrame - put image on whole video

 
* System overview 

** Overview

architecture pattern would be pipeline

** Components

 | Subsystem   | External dependencies | Consumes subsystem(s)    | Description                                                                    |
 |-------------+-----------------------+--------------------------+--------------------------------------------------------------------------------|
 | cmd         |                       | data, log                | Argument parsing and serializing given parameters                              |
 | net         | OpenMPI               | frame, data, ffmpeg, log | Node communication, data distribution and synchronization between nodes        |
 | other nodes |                       | other nodes              | Other nodes in network                                                         |
 | data        |                       |                          | Filter definitions, abstract data definitions                                  |
 | Log         | glog                  |                          | Logging capabilities and debugging capabilities                                |
 | ffmpeg      | libavcodec            | data, log                | FFMpeg wrapper classes                                                         |
 | video       |                       | data, log, frame         | Video reading and writing abstractions                                         |
 | frame       |                       | data                     | Frame transformation utilities                                                 |
 | plugin      | dlopen, env vars      | data, log, video         | Plugin loading, management for community filters and video writers and readers |



* Main concepts 

** Algorithms used 

in order to properly do division among nodes, we will need seek operation to be fast, this can be helpful

http://www.hackerfactor.com/blog/index.php?/archives/307-Picture-Go-Back.html

this can be used for splitting into segments

#+begin_src bash
  ffmpeg -i INPUT.mp4 -acodec copy -f segment -vcodec copy -reset_timestamps 1 -map 0 OUTPUT%d.mp4


#+end_src


*** Consensus

when writing output, all nodes keep track of last segment and they write their segments when it is their turn

since segments come in order, they can calculate when to write




** Data structures used 

The stream will be represented as a vector of segments where every segment is actually list of frames



* Quality attriubutes 

** Adaptability 

+ new filters and input and output reading/writing can be added through plugin system
+ nodes can see other nodes in the network because of OpenMPI
   
** Configuration

+ nodes are configured the same way as any OpenMPI application
+ ini files for plugin configuration can be found on filesystem by specified rules
   
** Logging and debug system

+ all logging is done on console
+ debug flags are available through verbosity option with different debug levels (=--debug LEVEL=) where level can be any number from 0 to 10
   
** Demonstrators 

+ on Borat movie - creating grayscale Borat
+ Borat movie, inserting watermark
+ Comparing this system with single core ffmpeg implementation for turning video into grayscale and resizing
   
** Deployment 

+ release is deployed on GitHub with tag and releases page
   
** Durability and warranty 

+ none, software is MIT licensed
   
** Functional safety 

+ not applicable
   
** Security 

+ not applicable
   
** Scalability 

+ yes through OpenMPI, other aspects will be only tested
   
** Standards and certification compliance 

+ all audio and video standards will be covered through ffmpeg


* Data design 

** File formats 

| Data type            | Format             |
|----------------------+--------------------|
| Video                | avi, mkv, mp4      |
| Filter               | shared object file |
| data input reader    | shared object file |
| data output writer   | shared object file |
| plugin configuration | ini file           |


* Communication to external systems 

| External system | data shared                       | protocol |
|-----------------+-----------------------------------+----------|
| OpenMPI network | Segment objects and metadata info | MPI      |


* Logging and error processing 

** Log subsystem

+ Implemented using glog
   
** Error reporting , handling and recovery

+ fail fast and fail early mechanism
+ does not try to recover at all
+ all fatal errors will also bring other nodes to finalize as quickly as possible

* Operating system and hardware compatibility 

+ compatible with Linux on high variety of hardware
  
* Plugin system 

** Interface to core system 

+ filters are implemented as plugins where every plugin contains:
  + class inheriting Filter base class
  + class inheriting FilterFactory which will create given object
  + Filter argument parser class inheriting =FilterArgumentParser= which is aimed to parse given parameters for filter and then call specific factory
  + =create_filter_parser_instance= function which returns filter parser implemented
+ writers and readers are implemented by:
  + inheriting =VideoReader= / =VideoWriter= class
  + creating =create_reader_instance= / =create_writer_instance= function which returns object of implemented class, both of them receive string path of file



** Plugin installation and management 

+ plugin is determined as directory containing:
  + manifest.ini file which has fields:
    + type
      + filter
      + reader
      + writer
    + for filter plugin:
      + name
      + shared object filename in the same directory
    + for reader / writer
      + file extensions which are supported
      + filename of shared object file 
   
* Build system 

+ CMake will be used
  

* Profiling 

+ valgrind will be used for measurements
  
* Testing frameworks 

** Unit testing 

+ google test
   
** Integration testing 

+ creating specialized programs to test components
   
** System testing 

+ creating swarm of containers

* Code coverage tools 

* Static code analysis 

* Documentation handling 

* Existing technologies dependencies 

+ glog
+ google test
+ docker for system testing
+ libav
+ ffmpeg
+ OpenMPI
+ cimg
  
* References
